1.多态
多态的核心是虚函数，虚函数会在类中产生虚函数表，里面存放虚函数的入口地址，是在编译过程中产生的。对象通过构造函数了会初始化一个指向虚函数表的指针。
对象的前四个字节是存放虚寒函数表的地址，当我们new一个对象是，会同过指针查找虚函数表的地址，从而找到正确版本。
继承如果无覆盖，那会先写一遍父类的虚函数，a::funa，再写自己的b::funa
如果覆盖，b::funca
多重继承会写在第一个继承虚函数表里面
2.函数传引用还是传指针的区别
函数传指针，是一种传值传递，传递的是地址值。会在栈中开辟一个空间存放实参值，而形参成为实参的副本，只是形参指向实参的地址。
函数传引用，也会在栈中开辟一个空间，但不会产生副本，实际是存放实参的地址，同过间接寻址的方式获取实参内容。
当数据量比较大时。
3.new和malloc的区别
一个是c++运算符，一个是库函数
一个在自由存储区申请内存，一个在堆上内存
一个可以重载，一个不可以
一个可以不需要指定内存的大小，通过operacte new 申请一块空间存放对象，调用构造函数初始化和赋值，返回自定义类型的指针，最后再通过与析构函数释放掉。
一个可以返回指定类型，一个必须是（void*）
自由存储区是c++new抽象的概念不等于堆
4.析构函数虚函数，构造函数虚函数
因为虚函数对应一个指向虚函数表的指针，他需要对象再实例化时，同过构造函数初始化。但是如果构造函数时虚函数，就需要通过虚函数表去查找调用，但是没有指向虚函数表的指针，所以不行。
一个对象的创建，是需要有完整的类型的。一个对象成功创建，由编译器获取实际类型。但如果构造函数为需函数，是在运行的时候才知道去调用哪一个类型的函数，
而具体哪一个类型又是编译器时期通过对象就应该确定的。
5.智能指针
uniqure——ptr一个栈变量，将对象的生命周期绑定在一起，当函数结束后自动释放
shard 计数器，当计数器为零的时候也会自动释放。
6，空类的大小：
空类的大小为1；
类的每个实例是独一无二的，而空类是可以实例化的，需要预留一个字节。
class A{}  SIZE:1
class b{vritual compe=0}size:4;有一个虚函数指针；
class c：：public b size：4；
class d：：vriu a，v b size:8;有一个虚函数指针，有一个指向基类的指针
有虚函数类的大小和虚函数的个数无关，都是4；
但和继承的分支数有关，和继承的虚函数表有关，多重继承n个
7.const修饰函数返回值
防止返回值引用被修改
引用作为返回值：
不能返回局部变量，
不能返回new开辟的内存的引用
9.引用和指针的区别
引用只要确定就不能改变
引用必须初始化
不存在空引用
10.class，struct，union
class默认是private，struct public
union成员共享一块内存地址
struct对齐数，是该成员大小和默认对齐数的最小值
是该成员最大字节数的整数被
内存地址的大小是成员最大值的整数倍
11.类型大小
32：double 8 8
    long   4 8
    *      4 8
12.重载，重写，覆盖
重载是在同一作用于下，参数名相同，参数列表不同（类型，个数，顺序）返回值可以不同
重写是在父类和子类之间，父类函数加上vritual，子类拥有函数名相同，参数列表，返回类型相同
覆盖是。。。。。。。。，可以没有。。。。，但是函数名相同，参数列表不同
13.静态编译和动态编译
静：就是在编译器编译可执行文件时，将可执行文件所用的静态库取出来，链接到可执行文件中去。好处就是执行速度快，不依赖动态链接库。但浪费空间，每个可执行文件都有一份副本，而且不容易更新。
动：将程序分成几个快，运行时才链接在一起，彼此共同一份副本。
14.栈和堆的区别
栈是系统自动申请，手动
申请后的响应，若申请的空间大于栈剩余空间，栈溢出
系统会维护一个链表，记录空闲内存的地址。寻找一个大于申请内存的堆结点，将其删除，将节点的内存分配给程序，将内存空间的首地址记录成开辟空间的大小。
申请的大小固定，较小  较大。
15.sizeof
void a(char p[5])  s(5) = 4  ,一个指针的大小，因为数组传参，传入的是首地址的大小。
a ="abcd" s(a) = 5 ,还有个'/0'结尾。
16.初始化列表
对于类类型，少了一次默认构造函数的调用，会直接调用拷贝构造函数。如果不使用，会调用两次默认构造函数，和一次赋值运算符。
而且如果没有默认构造函数，类类型必须要用初始化列表初始化，因为他会调用拷贝构造函数。
然后对引用的初始化
对常量的初始化
都得使用初列
17.拷贝构造函数要用引用
调用时机：赋值给类，类为参数，返回类
默认是浅拷贝，深拷贝：如果含有指针或者说是动态成员的话，若使用浅拷贝，会让一个地址由两个对象指向，析构时会导致一块地址被重复释放。
指针悬挂：野指针，指向未知内存，由于析构没有为空，没有初始化。
不用引用会无限递归。
18.define和const和内联函数
define是在预处理  c是在编译和运行
define没有类型判断，不能调试因为预处理
define字符替换，谁要就替换，有多个副本，c就一个
19.static不能用作虚函数
static没有隐藏this指针，所以不能通过对象调用，而虚函数的核心，就是通过对象去调用
公用一块地址，编译时期就存在了，不属于对象，而属于类
静态函数智能调用静态变量
类名：：函数名
