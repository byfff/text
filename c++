1.多态
多态的核心是虚函数，虚函数会在类中产生虚函数表，里面存放虚函数的入口地址，是在编译过程中产生的。对象通过构造函数了会初始化一个指向虚函数表的指针。
对象的前四个字节是存放虚寒函数表的地址，当我们new一个对象是，会同过指针查找虚函数表的地址，从而找到正确版本。
继承如果无覆盖，那会先写一遍父类的虚函数，a::funa，再写自己的b::funa
如果覆盖，b::funca
多重继承会写在第一个继承虚函数表里面
2.函数传引用还是传指针的区别
函数传指针，是一种传值传递，传递的是地址值。会在栈中开辟一个空间存放实参值，而形参成为实参的副本，只是形参指向实参的地址。
函数传引用，也会在栈中开辟一个空间，但不会产生副本，实际是存放实参的地址，同过间接寻址的方式获取实参内容。
当数据量比较大时。
3.new和malloc的区别
一个是c++运算符，一个是库函数
一个在自由存储区申请内存，一个在堆上内存
一个可以重载，一个不可以
一个可以不需要指定内存的大小，通过operacte new 申请一块空间存放对象，调用构造函数初始化和赋值，返回自定义类型的指针，最后再通过与析构函数释放掉。
一个可以返回指定类型，一个必须是（void*）
自由存储区是c++new抽象的概念不等于堆
4.析构函数虚函数，构造函数虚函数
因为虚函数对应一个指向虚函数表的指针，他需要对象再实例化时，同过构造函数初始化。但是如果构造函数时虚函数，就需要通过虚函数表去查找调用，但是没有指向虚函数表的指针，所以不行。
5.智能指针
uniqure——ptr一个栈变量，将对象的生命周期绑定在一起，当函数结束后自动释放
shard 计数器，当计数器为零的时候也会自动释放。
6，空类的大小：
空类的大小为1；
类的每个实例是独一无二的，而空类是可以实例化的，需要预留一个字节。
class A{}  SIZE:1
class b{vritual compe=0}size:4;有一个虚函数指针；
class c：：public b size：4；
class d：：vriu a，v b size:8;有一个虚函数指针，有一个指向基类的指针
有虚函数类的大小和虚函数的个数无关，都是4；
但和继承的分支数有关，和继承的虚函数表有关，多重继承n个
7.初始化列表的原因

